{"cells":[{"metadata":{"_kg_hide-input":true,"trusted":true,"_kg_hide-output":true},"cell_type":"code","source":"# config\nset.seed(123456)\noptions(repr.plot.width = 20, repr.plot.height = 12)\noptions(encoding = 'UTF-8')\n\nlist.of.packages <- c(\"ggwordcloud\")\nnew.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,\"Package\"])]\nif(length(new.packages)) install.packages(new.packages)\n","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"# Trabalho em Grupo\n(até 4 integrantes)\n\n- **Curso:** FGV MBA - Business Analytics and Big Data\n- **Disciplina:** Análise de Mídias Sociais e Mineração de Texto\n- **Professor:** Gustavo Mirapalheta\n\n## Alunos\n|Github|Nome|Matricula|E-mail|\n|---|---|---|---|\n|<a href=\"https://github.com/DanielFCampos\"><img src=\"https://avatars2.githubusercontent.com/u/31582602?s=460&v=4\" title=\"DanielFCampos\" width=\"40\" height=\"40\"></a>|Daniel Campos|A57635769|[daniel.ferraz.campos@gmail.com](daniel.ferraz.campos@gmail.com)|\n|<a href=\"https://github.com/ldaniel\"><img src=\"https://avatars2.githubusercontent.com/u/205534?s=460&v=4\" title=\"ldaniel\" width=\"40\" height=\"40\"></a>|Leandro Daniel|A57622988|[contato@leandrodaniel.com](contato@leandrodaniel.com)|\n|<a href=\"https://github.com/RodriGonca\"><img src=\"https://avatars2.githubusercontent.com/u/50252438?s=460&v=4\" title=\"RodriGonca\" width=\"40\" height=\"40\"></a>|Rodrigo Goncalves|A57566093|[rodrigo.goncalves@me.com](rodrigo.goncalves@me.com)|\n|<a href=\"https://github.com/ygorlima1\"><img src=\"https://avatars2.githubusercontent.com/u/52429828?s=460&v=4\" title=\"ygorlima1\" width=\"40\" height=\"40\"></a>|Ygor Lima|A57549661|[ygor_redesocial@hotmail.com](ygor_redesocial@hotmail.com)|"},{"metadata":{},"cell_type":"markdown","source":"# Enunciado\n\nApresente uma análise exploratória de dados utilizando as técnicas de Text Mining desenvolvidas na disciplina Análise de Mídias Sociais e Mineração de Texto.\n\nDecidimos aplicar as técnicas discutidas em sala de aula em um dataset contendo letras de músicas."},{"metadata":{},"cell_type":"markdown","source":"# Libraries"},{"metadata":{},"cell_type":"markdown","source":"Aqui estão todas as bibliotecas necessárias para este exercício."},{"metadata":{"trusted":true,"_kg_hide-input":false,"_kg_hide-output":true},"cell_type":"code","source":"# Data wrangling\nlibrary(dplyr, warn.conflicts = FALSE)\nlibrary(tidyr, warn.conflicts = FALSE)\nlibrary(readr)\nlibrary(stringr)\nlibrary(tidytext)\nlibrary(ggplot2)\nlibrary(forcats)\n\n# wordcloud\nlibrary(ggwordcloud)\n\n# network\nlibrary(visNetwork)\nlibrary(IRdisplay)\nlibrary(igraph, warn.conflicts = FALSE)\n\n# topic modeling\nlibrary(topicmodels)\n","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"# Importar e efetuar a limpeza dos dados"},{"metadata":{"_uuid":"051d70d956493feee0c6d64651c6a088724dca2a","_execution_state":"idle","trusted":true,"_kg_hide-input":false,"_kg_hide-output":false},"cell_type":"code","source":"# data ingestion\nlyrics <- read_csv('../input/380000-lyrics-from-metrolyrics/lyrics.csv',\n                   col_types = cols(\n                     index = col_double(),\n                     song = col_character(),\n                     year = col_double(),\n                     artist = col_character(),\n                     genre = col_character(),\n                     lyrics = col_character()),\n                  locale = locale(encoding = 'UTF-8'))\n\nprint(paste('Número de observações: ', length(lyrics$index)))\n","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"Vamos eliminar as observações sem letras, sem identificação do gênero musical e anteriores a 1970, dado que temos poucas observações anteriores a 1970."},{"metadata":{"trusted":true,"_kg_hide-input":false,"_kg_hide-output":false},"cell_type":"code","source":"# data filter\nlyrics <- filter(lyrics, \n                 !is.na(lyrics), \n                 !(genre %in% c('Not Available', 'Other')),\n                 as.integer(year) >= 1970)\n\n# uncomment for fast prototyping\nlyrics  <- sample_n(lyrics, size = 100000)\n# invisible(gc())\n\nprint(paste('Número de observações: ', length(lyrics$index)))\n","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"Vamos incluir a identificação da década de lançamento da música para podermos avaliar alterações ao longo do tempo"},{"metadata":{"trusted":true,"_kg_hide-input":false},"cell_type":"code","source":"# data enhance\nlyrics$decade <- paste(str_sub(lyrics$year, 1, 3), '0', sep = '')\nlyrics$genre  <- trimws(lyrics$genre)\n\nsaveRDS(lyrics, 'lyrics.rds')\n","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"Uma amostra do dataset."},{"metadata":{"trusted":true,"_kg_hide-input":true},"cell_type":"code","source":"# view sample\nsample_n(lyrics, 3)\n","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"# Análise Exploratória dos Dados Inicial"},{"metadata":{},"cell_type":"markdown","source":"Quantidade de músicas e artistas por gênero musical."},{"metadata":{"trusted":true,"_kg_hide-input":true},"cell_type":"code","source":"# view number of observations per genre\ntemp <- group_by(lyrics, genre) %>%\n  summarise(songs = n(),\n            artists = length(unique(artist))) %>% \n  arrange(desc(songs))\n\nggplot(data = temp, aes(x = fct_reorder(genre, songs), y = songs)) +\n    geom_bar(stat = 'identity', aes(fill = genre)) +\n    geom_label(aes(label = paste('songs:', songs, '\\nartists: ', artists, sep = ''),\n                   y = 1000, fill = genre), size = 8, hjust = 'left', alpha = 0.25) +\n    coord_flip() +\n    xlab('Genre') +\n    ylab('') +\n    labs(title = 'Songs and Artists by Genre') +\n    theme(legend.position = 0,\n         text = element_text(size = 20),\n         axis.text.x = element_blank())\n","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"Quantidade de músicas e artistas por década."},{"metadata":{"trusted":true,"_kg_hide-input":true},"cell_type":"code","source":"# view number of observations per decade\ntemp  <- group_by(lyrics, decade) %>% \n            summarise(songs = n(),\n                      artists = length(unique(artist))) %>% \n            arrange(desc(decade))\n\nggplot(data = temp, aes(x = decade, y = songs)) +\n    geom_bar(stat = 'identity', aes(fill = decade)) +\n    geom_label(aes(label = paste('songs:', songs, '\\nartists: ', artists, sep = ''),\n                   y = 1000, fill = decade), size = 8, hjust = 'left', alpha = 0.25) +\n    coord_flip() +\n    xlab('Decade') +\n    ylab('') +\n    labs(title = 'Songs and Artists by Decade') +\n    theme(legend.position = 0,\n         text = element_text(size = 20),\n         axis.text.x = element_blank())\n","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"Top 3 artistas, em relação a quantidade de músicas, por gênero."},{"metadata":{"trusted":true,"_kg_hide-input":true},"cell_type":"code","source":"# view top artists\ncount(lyrics, genre, artist, sort = TRUE) %>% \n  group_by(genre) %>% \n  arrange(desc(n)) %>% \n  filter(row_number() <= 3) %>% \n  arrange(desc(genre), desc(n))\n","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"# Análise Exploratória de Dados"},{"metadata":{},"cell_type":"markdown","source":"## Análise de palavras mais comuns."},{"metadata":{},"cell_type":"markdown","source":"Vamos utilizar o pacote tidytext para tokenizar os termos em um dataframe contendo uma palavra por linha."},{"metadata":{"trusted":true,"_kg_hide-input":false},"cell_type":"code","source":"# tokens per word\nlyrics_token <- unnest_tokens(lyrics,\n                              input = lyrics,\n                              output = word,\n                              token = 'words',\n                              drop = TRUE,\n                              to_lower = TRUE)\n\nprint(paste('Número de observações: ', length(lyrics_token$index)))\n","execution_count":null,"outputs":[]},{"metadata":{"_kg_hide-input":true,"_kg_hide-output":true,"trusted":true},"cell_type":"code","source":"rm(lyrics)\ninvisible(gc())","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"Algumas músicas, ou mesmo parte da letra, estão em outros idiomas além do inglês. <br>\n\nPara resolver isso vamos aplicar mais dois filtros, onde eliminamos termos que não iniciam com letras {a- z} e stop words em outros idiomas de origem latina."},{"metadata":{"trusted":true,"_kg_hide-input":true},"cell_type":"code","source":"# eliminating stop words\ncustom_stop_words <- c(tm::stopwords(\"german\"), tm::stopwords(\"spanish\"), \n                       tm::stopwords(\"portuguese\"), tm::stopwords(\"french\"),\n                       stop_words$word, 'chorus', 'repeat', 'versus', 'chorus:repeat')\n\nlyrics_token <- filter(lyrics_token,\n                       str_detect(word, '^[a-z]') &\n                       !(word %in% custom_stop_words))\n\nbing = get_sentiments('bing')\nlyrics_token$sentiment = plyr::mapvalues(lyrics_token$word, \n                                         bing$word, bing$sentiment, \n                                         warn_missing = FALSE)\n\nlyrics_token$sentiment = if_else(!(lyrics_token$sentiment %in% c('positive', 'negative')), \n                                    'neutral', lyrics_token$sentiment)\n\nprint(paste('Número de observações após a eleminação das stop words: ', \n            length(lyrics_token$index)))\n\nsample_n(lyrics_token, size = 15)\n\ncount_words <- count(lyrics_token, word, sentiment, sort = TRUE)\n\n# saving datasets for later use.\nsaveRDS(lyrics_token, 'lyrics_token.rds')\nsaveRDS(count_words, 'count_words.rds')\n\nrm(bing, count_words)\ninvisible(gc)\n","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"De posse do dataset organizado, vamos iniciar com a contagem relativa dos termos por artista e gênero musical."},{"metadata":{"trusted":true,"_kg_hide-input":true},"cell_type":"code","source":"# contagem por gênero musical\ngw <- group_by(lyrics_token, genre, sentiment, word) %>%\n  summarise(gw_c = n()) %>% \n  ungroup() %>% \n  group_by(genre) %>%\n  mutate(gw_p = gw_c / sum(gw_c)) %>% \n  ungroup() %>%\n  arrange(genre, desc(gw_p)) %>% \n  group_by(word) %>% \n  mutate(w_c = sum(gw_c))\n\n# contagem por palavra\nw <- group_by(lyrics_token, sentiment, word) %>%\n  summarise(w_c = n()) %>% \n  ungroup() %>%\n  mutate(w_p = w_c / sum(w_c)) %>%\n  arrange(desc(w_c))\n\nrm(lyrics_token)\ninvisible(gc)\n","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"Vamos iniciar a exploração observando as 100 palavras mais comuns encontradas no dataset."},{"metadata":{"trusted":true,"_kg_hide-input":true},"cell_type":"code","source":"# view word cloud\ntemp <- group_by(w, sentiment) %>% \n    arrange(desc(w_c)) %>% \n    filter(row_number() < 101) %>% \n    mutate(angle = 90 * sample(c(0, 1), n(), replace = TRUE, prob = c(70, 30)),\n          freq_sd = (w_c - min(w_c)) / (max(w_c) - min(w_c))) %>% \n    ungroup()\n\noptions(repr.plot.width = 20, repr.plot.height = 6)\n\nplt  <- ggplot(data = temp,\n  aes(label = word, \n      size = w_c,\n      color = factor(sentiment), \n      angle = angle)) +\n  geom_text_wordcloud_area(eccentricity = 0.65) +\n  facet_wrap(vars(sentiment), nrow = 1) +\n  scale_size_area(max_size = 35) +\n  theme_minimal() +\n  theme(text = element_text(size = 20))\n\nsuppressWarnings(print(plt))\n\nrm(w)\ninvisible(gc)","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"Também podemos verificar as palavras mais utilizadas por sentimento e gênero musical.\n\nAqui o tamanho de cada termo é dado pela frequência de cada sentimento e gênero musical, de forma que quanto maior a nuvem de palavra maior a diversidade de palavras utilizadas para o a combinação de sentimento e gênero musical.\n"},{"metadata":{"trusted":true,"_kg_hide-input":true},"cell_type":"code","source":"# view word cloud per genre\ntemp <- group_by(gw, genre, sentiment) %>%  \n    arrange(desc(gw_p)) %>% \n    filter(row_number() < 51) %>%\n    mutate(angle = 90 * sample(c(0, 1), n(), replace = TRUE, prob = c(70, 30)), \n           freq_sd = (gw_c - min(gw_c)) / (max(gw_c) - min(gw_c))) %>% \n    ungroup()\n\noptions(repr.plot.width = 20, repr.plot.height = 48)\n\nplt <- ggplot(data = temp,\n  aes(label = word, \n      size = freq_sd,\n      color = factor(sample.int(20, nrow(temp), replace = TRUE)), \n      angle = angle)) +\n  geom_text_wordcloud_area() +\n  scale_size_area(max_size = 25) +\n  facet_wrap(genre ~ sentiment, nrow = 10) +\n  theme(text = element_text(size = 15))\n\nsuppressWarnings(print(plt))\n","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"Na sequência vamos verificar se as 10 palavras mais comuns são uniformes entre os gêneros musicais presentes no dataset."},{"metadata":{"trusted":true,"_kg_hide-input":true},"cell_type":"code","source":"# view most common words\noptions(repr.plot.width = 20, repr.plot.height = 12)\n\ngw %>%\n  group_by(genre) %>% \n  arrange(desc(gw_p)) %>% \n  filter(row_number() <= 10) %>%\n  mutate(rank = row_number()) %>% \n  ggplot() +\n  geom_bar(stat = 'identity',\n           aes(y = gw_p, x = fct_reorder(word, w_c), fill = genre)) +\n  geom_text(aes(label = as.character(rank), x = fct_reorder(word, w_c), y = 0.002)) +\n  facet_wrap(vars(genre), nrow = 1) +\n  coord_flip() +\n  xlab('Word') +\n  ylab('Relative frequency') +\n  labs(title = 'Top 10 words by music genre') +\n  theme(legend.position = 0,\n        axis.text.x = element_blank(),\n        axis.ticks.x = element_blank(),\n        text = element_text(size = 20))\n\nrm(gw)\ninvisible(gc)\n","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"Como podemos observar pelo gráfico acima em geral as top 10 palavras são as mesmas entre os gêneros, porém, os gêneros Metal e Hip-Hop se destacam com diferentes temas em relação aos demais gêneros. <br>\n\nTambém observamos que Country, Folk e Indie abordam com maior frequência o tema \"*Home*\" em relação aos demais."},{"metadata":{},"cell_type":"markdown","source":"## Análise de Bigramas"},{"metadata":{},"cell_type":"markdown","source":"Além da análise das palavras mais comuns podemos explorar quais são os Bigramas e Trigramas mais comuns utilizados."},{"metadata":{"trusted":true,"_kg_hide-input":true},"cell_type":"code","source":"# tokens bigramas\nlyrics <- readRDS('lyrics.rds')\n\nlyrics_token_bi <- unnest_tokens(lyrics,\n                                 input = lyrics,\n                                 output = term,\n                                 token = 'ngrams',\n                                 drop = TRUE,\n                                 to_lower = TRUE,\n                                 n = 2)\n\nprint(paste('Número de termos: ', length(lyrics_token_bi$index)))\n","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"Agora separamos o bigrama em duas palavras para eliminarmos os bigramas que contem stop words assim como fizemos com o a análise de palavras individuais. <br>\n\nIremos eliminar as linhas onde ao menos uma das palavras do bigrama são stop words."},{"metadata":{"_kg_hide-input":true,"trusted":true,"_kg_hide-output":true},"cell_type":"code","source":"rm(lyrics)\ninvisible(gc())","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"Assim como fizemos com as palavras unitárias necessitamos excluir as stop words dos bigramas.\n\nAlém das stop words, por estarmos analisando letras de músicas, também vamos excluir os bigramas com palavras repetidas."},{"metadata":{"trusted":true,"_kg_hide-input":false},"cell_type":"code","source":"# clean bigrams\nlyrics_token_bi <- separate(lyrics_token_bi, term, \n                            sep = ' ', \n                            into = c('w1', 'w2'), \n                            remove = FALSE)\nlyrics_token_bi <- filter(lyrics_token_bi, \n                          !(w1 %in% custom_stop_words) & str_detect(w1, '^[a-z]'))\nlyrics_token_bi <- filter(lyrics_token_bi, \n                          !(w2 %in% custom_stop_words) & str_detect(w2, '^[a-z]'))\ninvisible(gc())\nlyrics_token_bi <- filter(lyrics_token_bi, w1 != w2)\nsaveRDS(lyrics_token_bi, 'lyrics_token_bi.rds')\n\nprint(paste('Número de termos apos eliminação de stop words: ', \n            length(lyrics_token_bi$index)))\n\nrm(lyrics_token_bi)\ninvisible(gc)\n","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"Vamos criar uma função para gerar um diagrama de rede com os 5 bigramas mais comuns para cada palavras selecionadas."},{"metadata":{"trusted":true},"cell_type":"code","source":"# custom function to plot network diagram\nplot_network <- function(top_words = 25, \n                         artist_filter = NULL, \n                         genre_filter = NULL) {\n    # load required data\n    count_words  <- readRDS('lyrics_token.rds')\n    data         <- readRDS('lyrics_token_bi.rds')\n    \n    # apply filters\n\n    if (!is.null(artist_filter)) {count_words  <- filter(count_words, \n                                                         artist %in% artist_filter)}\n    if (!is.null(genre_filter)) {count_words   <- filter(count_words, \n                                                         genre %in% genre_filter)}\n    count_words  <- count(count_words, word, sentiment, sort = TRUE)\n    top_words <- filter(count_words, row_number() <= top_words)\n    if (!is.null(artist_filter)) {data  <- filter(data, \n                                                  artist %in% artist_filter)}\n    if (!is.null(genre_filter)) {data  <- filter(data, \n                                                 genre %in% genre_filter)}\n    data <- group_by(data, w1, w2) %>% \n               summarise(count = n()) %>%\n               ungroup() %>%\n               mutate(percent = count / sum(count)) %>%\n               group_by(w1) %>%\n               arrange(desc(count)) %>%\n               filter(row_number() <= 5) %>% \n               ungroup() %>% \n               filter(w1 %in% top_words$word)\n\n    # set nodes\n    nodes = tibble(label = unique(c(data$w1, data$w2)))\n    nodes = tibble::rowid_to_column(nodes, \"id\")\n    nodes$value = plyr::mapvalues(nodes$label, count_words$word, \n                                  count_words$n, warn_missing = FALSE)\n    nodes$value = as.numeric(nodes$value)\n    nodes$value = (nodes$value - min(nodes$value)) / \n                                    (max(nodes$value) - min(nodes$value))\n    nodes$value = nodes$value * 100\n    nodes$group = plyr::mapvalues(nodes$label, count_words$word, \n                                  count_words$sentiment, warn_missing = FALSE)\n\n    # set edges\n    edges  <- tibble(from   = data$w1,\n                     to     = data$w2,\n                     weight = data$percent)\n    edges$from = plyr::mapvalues(edges$from, nodes$label, \n                                 nodes$id, warn_missing = FALSE)\n    edges$to = plyr::mapvalues(edges$to, nodes$label, \n                               nodes$id, warn_missing = FALSE)\n\n    net_graph <- visNetwork(nodes, edges, height = \"500px\", width = \"100%\") %>% \n                     visNodes(scaling = list(min = 10, max = 50), \n                              physics = TRUE, mass = 1.25) %>% \n                     visEdges(arrows = \"to\") %>% \n                     visOptions(highlightNearest = TRUE, \n                                nodesIdSelection = TRUE,\n                                selectedBy = \"group\") %>%\n                     visGroups(groupname = \"positive\", color = \"green\")  %>% \n                     visGroups(groupname = \"neutral\") %>% \n                     visGroups(groupname = \"negative\", color = \"red\") %>% \n                     visLegend(width = 0.1)\n    \n    rm(count_words, data)\n    invisible(gc)\n    \n    # return graph\n    return (net_graph)\n}\n","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"Aqui estamos vendo os 5 bigramas mais comuns para as 25 palavras mais usadas em todo o data set."},{"metadata":{"trusted":true,"_kg_hide-input":true},"cell_type":"code","source":"# bigrams graph for all dataset\nnet_graph <- plot_network(top_words = 25)\n\nhtmlwidgets::saveWidget(net_graph, \"net_graph.html\")\n\ndisplay_html('<iframe src=\"net_graph.html\" width=100% height=600></iframe>')\n","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"Agora podemos aplicar um filtro no dataset de bigramas e verificar a rede de bigramas de um artista em aprticular como Bob Dylan.\n\nAqui estamos vendo os 5 bigramas mais comuns para as 50 palavras mais usadas pelo artista."},{"metadata":{"trusted":true},"cell_type":"code","source":"# bigrams graph for one artist\nnet_graph <- plot_network(top_words = 50, artist_filter = 'bob-dylan')\n\nhtmlwidgets::saveWidget(net_graph, \"net_graph_artist.html\")\n\ndisplay_html('<iframe src=\"net_graph_artist.html\" width=100% height=600></iframe>')\n","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"Podemos fazer o mesmo filtro para um gênero específico como Metal e Rock."},{"metadata":{"trusted":true},"cell_type":"code","source":"# bigrams graph for one genre\nnet_graph <- plot_network(top_words = 25, genre_filter = 'Metal')\n\nhtmlwidgets::saveWidget(net_graph, \"net_graph_genre.html\")\n\ndisplay_html('<iframe src=\"net_graph_genre.html\" width=100% height=600></iframe>')\n","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"# bigrams graph for one genre\nnet_graph <- plot_network(top_words = 25, genre_filter = 'Rock')\n\nhtmlwidgets::saveWidget(net_graph, \"net_graph_genre.html\")\n\ndisplay_html('<iframe src=\"net_graph_genre.html\" width=100% height=600></iframe>')\n","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"A exemplo do que fizemos com a contagem individual de palavras vamos verificar quais os bigramas mais utilizados por gênero musical."},{"metadata":{"trusted":true,"_kg_hide-input":false,"_kg_hide-output":false},"cell_type":"code","source":"# contagem por gênero musical\nlyrics_token_bi <- readRDS('lyrics_token_bi.rds')\n\ngw <- group_by(lyrics_token_bi, genre, term) %>%\n  summarise(gw_c = n()) %>% \n  ungroup() %>% \n  group_by(genre) %>%\n  mutate(gw_p = gw_c / sum(gw_c)) %>% \n  ungroup() %>%\n  arrange(genre, desc(gw_p)) %>% \n  group_by(term) %>% \n  mutate(w_c = sum(gw_c))\n\n# contagem por palavra\nw <- group_by(lyrics_token_bi, term) %>%\n  summarise(w_c = n()) %>% \n  ungroup() %>%\n  mutate(w_p = w_c / sum(w_c)) %>%\n  arrange(desc(w_c))\n\nrm(lyrics_token_bi)\ninvisible(gc)\n","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"Vamos verificar a nuvem de termos de bigramas."},{"metadata":{"trusted":true,"_kg_hide-input":true},"cell_type":"code","source":"# wordcloud commom bigrams\ntemp <- arrange(w, desc(w_c)) %>% \n    filter(row_number() < 101) %>% \n    mutate(angle = 90 * sample(c(0, 1), n(), replace = TRUE, prob = c(70, 30)))\n\nplt <- ggplot(data = temp,\n  aes(label = term, \n      size = w_c,\n      color = factor(sample.int(20, nrow(temp), replace = TRUE)), \n      angle = angle)) +\n  geom_text_wordcloud_area(eccentricity = 1.1) +\n  scale_size_area(max_size = 25) +\n  theme_minimal()\n\nrm(w)\ninvisible(gc)\n\nsuppressWarnings(print(plt))\n","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_kg_hide-input":true},"cell_type":"code","source":"# word cloud commom bigrams per genre\ntemp <- group_by(gw, genre) %>%  \n    arrange(desc(gw_p)) %>% \n    filter(row_number() < 26) %>%\n    mutate(angle = 90 * sample(c(0, 1), n(), replace = TRUE, prob = c(100, 0)), \n           freq_sd = (gw_c - min(gw_c)) / (max(gw_c) - min(gw_c))) %>% \n    ungroup()\n\noptions(repr.plot.width = 20, repr.plot.height = 24)\n\nplt <- ggplot(data = temp,\n  aes(label = term, \n      size = freq_sd,\n      color = factor(sample.int(20, nrow(temp), replace = TRUE)), \n      angle = angle)) +\n  geom_text_wordcloud_area() +\n  scale_size_area(max_size = 20) +\n  facet_wrap(vars(genre), nrow = 5) +\n  theme(text = element_text(size = 20))  \n\nsuppressWarnings(print(plt))\n","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"Agora verificamos os top 5 bigramas por gênero musical."},{"metadata":{"trusted":true,"_kg_hide-input":false},"cell_type":"code","source":"# most commom bigrams per genre\noptions(repr.plot.width = 20, repr.plot.height = 12)\n\ngw %>%\n  group_by(genre) %>% \n  arrange(desc(gw_p)) %>% \n  filter(row_number() <= 5) %>%\n  mutate(rank = row_number()) %>% \n  ggplot() +\n  geom_bar(stat = 'identity',\n           aes(y = gw_p, x = fct_reorder(term, w_c), fill = genre)) +\n  geom_text(aes(label = as.character(rank), x = fct_reorder(term, w_c), y = 0.0002)) +\n  facet_wrap(vars(genre), nrow = 1) +\n  coord_flip() +\n  xlab('Term') +\n  ylab('Relative frequency') +\n  labs(title = 'Top 5 bigrams by music genre') +\n  theme(legend.position = 0,\n        axis.text.x = element_blank(),\n        axis.ticks.x = element_blank(),\n        text = element_text(size = 20))\n\nrm(gw)\ninvisible(gc)\n","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"# TF-IDF (Term Frequency - Inverse Document Frequency)"},{"metadata":{},"cell_type":"markdown","source":"Esta métrica é uma medida estatística que tem o intuito de indicar a importância de uma palavra de um documento em relação a uma coleção de documentos.\n\nO valor tfidf de uma palavra aumenta proporcionalmente à medida que aumenta o número de ocorrências dela em um documento, no entanto, esse valor é equilibrado pela frequência da palavra no corpus. Isso auxilia a distinguir o fato de a ocorrência de algumas palavras serem geralmente mais comuns que outras como as stopwords.\n\n\\begin{equation}\nW_{i,j} = tf_{i,j} * log(\\frac{N}{df_i})\n\\end{equation}\n\n\\begin{equation}\ntf_{i,j} = \\text{ número de ocorrencias do termo } \\textit{( i )} \\text{ em } \\textit{ j } \\text{ (documento)}\n\\end{equation} \n\n\\begin{equation}\ndf_{i} = \\text{ número de documentos contendo } \\textit {i}\n\\end{equation} \n\n\\begin{equation}\nN = \\text{ número total de documentos }\n\\end{equation} \n\n\\begin{equation}\nW_{i,j} = \\text{ Term Frequency - Inverse Document Frequency }\n\\end{equation} \n\nNeste exercício o documento será um gênero musical.\n\nVamos verificar se conseguimos identificar as principais palavras de cada gênero musical sem o auxílio de um dicionário de stopwords."},{"metadata":{},"cell_type":"markdown","source":"Começamos calculando a frequência de cada termo."},{"metadata":{"trusted":true,"_kg_hide-input":true},"cell_type":"code","source":"# load lyrics dataset back to memory.\nlyrics <- readRDS('lyrics.rds')\n\n# tokennize dataset but do not treat for stopwords.\nlyrics_token <- unnest_tokens(lyrics,\n                              input = lyrics,\n                              output = word,\n                              token = 'words',\n                              drop = TRUE,\n                              to_lower = TRUE)\n\n# calculate the term frequency by gere.\nlyrics_token <- lyrics_token[, c('genre','word')] %>% \n    filter(str_detect(word, \"^[a-z']\")) %>% \n    group_by(genre, word) %>% \n    summarise(n = n()) %>% \n    group_by(genre) %>% \n    mutate(total = sum(n)) %>% \n    mutate(tf = n / total) %>% \n    group_by(genre) %>% \n    arrange(desc(n)) %>%\n    mutate(rank_tf = row_number()) %>%\n    ungroup()\n\n# display the most commom terms based on its term frequency.\n    filter(lyrics_token, rank_tf <= 3) %>% \n    arrange(genre, rank_tf)\n\nrm(lyrics)\ninvisible(gc)","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"Podemos perceber que são exatamente as stop words os termos com maior frequência.\n\nPodemos visualizar a quantidade de termos por frequência em um histograma.\n\nVerificamos que a maioria dos termos tem uma frequência muito baixa, como é esperado."},{"metadata":{"trusted":true,"_kg_hide-input":true},"cell_type":"code","source":"# histogram of term frequency\noptions(repr.plot.width = 20, repr.plot.height = 24)\n\nggplot(lyrics_token, aes(x = n / total, fill = genre)) +\n  geom_histogram(show.legend = FALSE, bins = 100) + \n  facet_wrap( ~ genre, ncol = 2, scales = 'free') +\n  theme(text = element_text(size = 20))\n","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"Aqui verificamos a relação entre a frequência do termo no gênero com o rank do termo.\n\nO gráfico abaixo está em escala logarítmica."},{"metadata":{"trusted":true,"_kg_hide-input":true},"cell_type":"code","source":"# term frequency vs rank\noptions(repr.plot.width = 20, repr.plot.height = 12)\n\nggplot(lyrics_token, aes(x = rank_tf, y = tf, color = genre)) +\n  geom_line(alpha = 0.8, size = 1.1, show.legend = FALSE) +\n  scale_x_log10() + scale_y_log10() +\n  xlab(\"Rank - Term frequency\") + ylab(\"Term frequency\") +\n  theme(text = element_text(size = 20))\n","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"\nO fato de haver algumas canções em outros idiomas, que não o inglês, faz com que a técnica TF-IDF não seja bem-sucedida em eliminar as stopwords pois em geral as stop words.\n\nEm geral as stop words estão presentes em todos os documentos, fazendo com que o termo $ log(\\frac{N}{df_i}) $ tenha o resultado zero, zerando assim a estatística TF-IDF para o termo."},{"metadata":{"trusted":true,"_kg_hide-output":false,"_kg_hide-input":true},"cell_type":"code","source":"# augment the term frequency data frame with inverse document frequency data.\nlyrics_token <- bind_tf_idf(tbl = lyrics_token,  \n                            term = word, \n                            document = genre, \n                            n = n) %>% \n                arrange(desc(tf_idf)) %>% \n                group_by(genre) %>% \n                mutate(rank_tf_idf  = row_number()) %>% \n                arrange(genre, rank_tf_idf) %>% \n                ungroup()\n\nfilter(lyrics_token, rank_tf_idf  <= 3)\n","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_kg_hide-input":true},"cell_type":"code","source":"# top words by genre using TF-IDF\noptions(repr.plot.width = 20, repr.plot.height = 24)\n\n    group_by(lyrics_token, genre) %>%\n    top_n(10, tf_idf) %>%\n    ungroup() %>% \n    mutate(word = reorder(word, desc(tf_idf))) %>% \n    ggplot(aes(x = fct_reorder(word, tf_idf), \n               y = tf_idf, \n               fill = genre)) +\n        geom_col(show.legend = FALSE) +\n        facet_wrap( ~ genre, ncol = 2, scales = \"free\") +\n        coord_flip() +\n        labs(x = NULL, y = \"TF-IDF\") +\n        theme(text = element_text(size = 20), \n              axis.ticks.x = element_blank(),\n              axis.text.x = element_blank())\n","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"rm(lyrics_token)\ninvisible(gc)","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"# LDA Topic Modelling"},{"metadata":{},"cell_type":"markdown","source":"Agora vamos tentar utilizar a técnica de topic modeling Latent Dirichlet Allocation (LDA) para responder a questão.\n\n> > **Seria possível classificar as canções em grupos que representam os seus respectivos gêneros musicais apenas analisando as letras das músicas?**\n\nIniciamos transformando nosso dataset em um matriz de frequência de documentos vs termos (Documento Term Matrix)\n\nO dataset que iremos utilizar é o mesmo onde já eliminamos as stop words no início de nosso exercício."},{"metadata":{"trusted":true},"cell_type":"code","source":"# create DTM\nlyrics_token <- readRDS('lyrics_token.rds')\n\ndtm <- cast_dtm(data = count(lyrics_token, index, word, sort = TRUE),\n                index, word, n)\ndtm\n\nsaveRDS(dtm, 'dtm.rds')","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"Agora treinamos um modelo com **10 tópicos** para verificarmos se eles de alguma forma representam os gêneros musicais presentes no dataset."},{"metadata":{"trusted":true},"cell_type":"code","source":"# calculating model with 10 topics\ntpm <- LDA(dtm, k = 10, control = list(seed = 123456))\n\ntpm\nsummary(tpm)\n\nsaveRDS(tpm, 'tpm.rds')\n\nrm(dtm)\ninvisible(gc)","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"Agora verificamos quais são os termos com maior $ \\beta $ que representa a probabilidade do termo pertencer ao tópico.\n\nPodemos verificar que alguns tópicos se parecem bastante com as palavras mais comuns de alguns gêneros musicais que observamos na fase de análise exploratória de dados.\n\nDestaque para o gênero **Hip-Hop** onde claramente conseguimos verificar os mesmos termos no tópico gerado pelo modelo.\n\nAlguns tópicos porém não fazem o menor sentido, claramente aqui temos o efeito de termos algumas músicas em outros idiomas, um tópico quase que classifica as canções em espanhol em um mesmo cluster."},{"metadata":{"trusted":true,"_kg_hide-input":true},"cell_type":"code","source":"# visualizing top words per topic\noptions(repr.plot.width = 20, repr.plot.height = 12)\n\nterm_topics <- tidy(tpm, matrix = \"beta\")\n\nterm_top_terms <- term_topics %>%\n  group_by(topic) %>%\n  top_n(10, beta) %>%\n  ungroup() %>%\n  arrange(topic, -beta)\n\nterm_top_terms %>%\n  mutate(term = reorder(term, beta)) %>%\n  ggplot(aes(term, beta, fill = factor(topic))) +\n  geom_col(show.legend = FALSE) +\n  facet_wrap(~ topic, scales = \"free\", nrow = 2) +\n  coord_flip() +\n  theme(text = element_text(size = 20), \n        axis.text.x = element_blank(), \n        axis.ticks = element_blank())\n\nrm(term_topics)\ninvisible(gc)","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"Podemos fazer a junção com o dataset de canções originais e verificar por gênero musical qual tópico cada canção foi assignada pelo modelo LDA.\n\nA probabilidade de cada canção pertencer a um determinado tópico é dada pela estatística **$ \\gamma $** do modelo LDA.\n"},{"metadata":{"trusted":true,"_kg_hide-input":true},"cell_type":"code","source":"# visualizing topic classification per genre\noptions(repr.plot.width = 20, repr.plot.height = 24)\n\nlyrics <- readRDS('lyrics.rds')\nsongs_topics <- tidy(tpm, matrix = \"gamma\")\n\nlyrics$index <- as.character(lyrics$index)\n\ninner_join(lyrics, songs_topics, by = c('index' = 'document')) %>% \n    select(index, song, year, artist, genre, decade, topic, gamma) %>% \n        ggplot(aes(x = factor(topic), y = gamma, fill = genre)) +\n            geom_boxplot(show.legend = FALSE) +\n            facet_wrap(~ genre, nrow = 5) +\n            xlab('Topic') + ylab('gamma') +\n            labs(title = 'Topic classification per Genre') +\n            theme(text = element_text(size = 20), \n                  axis.text.y = element_blank(), \n                  axis.ticks.y = element_blank())\n\nrm(lyrics, songs_topics)\ninvisible(gc)\n","execution_count":null,"outputs":[]}],"metadata":{"kernelspec":{"display_name":"R","language":"R","name":"ir"},"language_info":{"mimetype":"text/x-r-source","name":"R","pygments_lexer":"r","version":"3.4.2","file_extension":".r","codemirror_mode":"r"}},"nbformat":4,"nbformat_minor":1}